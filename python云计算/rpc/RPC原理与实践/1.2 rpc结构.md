# RPC结构

RPC的设计思想是力图**使远程调用中的通讯细节对于使用者透明**，调用双方无需关心网络通讯的具体实现。因而实现RPC要进行一定的封装。

RPC原理上是按如下结构流程进行实现的。

![RPC结构](file:///D:/python%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/grpc/Python%20Web%E6%96%B9%E5%90%91%E8%AF%BE%E7%A8%8B/2-4%20RPC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94gRPC/%E8%AF%BE%E4%BB%B6/RPC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E4%BB%BD%E8%AF%BE%E4%BB%B6/images/RPC%E7%BB%93%E6%9E%84.png)

#### 流程：

1. 调用者（Caller, 也叫客户端、Client）以本地调用的方式发起调用；
2. Client stub（客户端存根，可理解为辅助助手）收到调用后，负责将被调用的方法名、参数等打包编码成特定格式的能进行网络传输的消息体；
3. Client stub将消息体通过网络发送给对端（服务端）
4. Server stub（服务端存根，同样可理解为辅助助手）收到通过网络接收到消息后按照相应格式进行拆包解码，获取方法名和参数；
5. Server stub根据方法名和参数进行本地调用；
6. 被调用者（Callee，也叫Server）本地调用执行后将结果返回给server stub;
7. Server stub将返回值打包编码成消息，并通过网络发送给对端（客户端）；
8. Client stub收到消息后，进行拆包解码，返回给Client；
9. Client得到本次RPC调用的最终结果。

**RPC的目标就是要2~8这些步骤都封装起来，让使用者对这些细节透明。**

在了解了RPC流程之后，为了实现RPC，我们还需要关注两点：

- **消息协议**

  客户端调用的参数和服务端的返回值这些在网络上传输的数据以何种方式打包编码和拆包解码。

  我们可以使用HTTP协议中关于报文格式的规定（如此一来，就编程了HTTP通讯），也可以自己定义某种格式，让客户端与服务端双方都遵循此种格式。

- **传输控制**

  在网络中数据的收发传输控制具体如何实现。