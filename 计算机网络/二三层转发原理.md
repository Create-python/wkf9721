IP地址是一个32位的二进制数，通常被分割为4个***8位2进制数***，常用***点分十进制***来表示，例如：192.168.0.1，由32位0和1组成，写开就是，11000000.10101000.00000000.00000001 。

MAC地址，又叫物理地址，长度为48位的二进制数，通常表示为12个**16进制数**，

## 二层转发图示

![image-20220213160346230.png](https://github.com/Create-python/wkf9721/blob/master/images/image-20220213160346230.png?raw=true)


## 二层转发原理

① 查看目的主机的ip地址，对ip和掩码进行匹配，发现与自己的ip是同一网段。

② 以目的主机的ip地址为索引，查看自己的arp表项，不存在目的主机的MAC地址。

③ 主机A需要以广播的方式发送arp请求报文（源MAC,源IP，目的MAC,目的IP）。

④ 交换机接收到主机A发送的请求报文，解析报文，将主机A的MAC地址和端口号学习到自己的FDB表中。

⑤ 交换机会以广播的方式对除了源端口的其它所有端口转发请求报文。

⑥ 主机B发现报文的目的IP地址是自身，则先将源IP和MAC地址更新到自己的ARP表项中，而其它主机发现目的IP不是自身，则舍弃该报文。

⑦ 主机B以单播的方式发送一个应答报文。

⑧ 交换机接受到主机B发送的应答报文，解析头部获得并学习主机B的MAC地址和端口号到FDB表中。

⑨ 交换机直接将应答报文转发给主机A。

⑩ 主机A接收到来自交换机的ARP报文，解析并更新自己的ARP表项。

⑪ 主机A将ICMP报文封装成帧发送给主机B,交换机接收到报文后,发现源IP和MAC存在FDB表中，更新对应的老化标志，直接转发给主机B。





## 三层转发图示


![image-20220213184232955.png](https://github.com/Create-python/wkf9721/blob/master/images/image-20220213184232955.png?raw=true)


## 三层转发原理

① 主机A对主机B的IP地址和掩码进行演算得到主机B的网络号，发现和自身处于不同网段，因此向网关发送ARP请求获取网关的MAC地址。

② 网关接收到主机A发送的ARP请求后，解析报文发现目的IP是自己的三层接口IP，先是将主机A的IP地址、MAC地址、port端口，VLAN ID更新到自己的ARP表项中，以三层接口的IP和MAC作为源IP和MAC向主机发送应答报文。

③ 主机A收到网关发送的应答报文后，更新网关的IP地址和MAC地址到自己的ARP表项中，然后组装ICMP请求报文并发送给网关，报文目的IP是主机B，目的MAC是三层接口的MAC。

④ 网关收到来自主机A的ICMP报文后，解析报文发现目的MAC是自己三层接口的MAC，知道该报文需要做三层转发。

⑤ 网关根据报文的目的IP查找转发表项，因为之前未建立表项，因此查找失败，于是将报文交给CPU的软件路由处理。

⑥ CPU根据目的IP查询FIB表，发现目的IP匹配了一个直连网段，于是继续查找ARP表项，查找失败，于是在目的IP所在网段广播发送ARP请求获取主机B的MAC地址。

⑦ 主机B在接收该ARP请求报文后，匹配报文的目的IP和自身的IP发现相同，于是将网关的IP和MAC更新到自己的ARP表项中，并向网关发送应答报文。

⑧ 网关收到目的主机发送的应答报文后，将主机B的IP和MAC更新到自己的ARP表项中，并将主机A发送的ICMP报文发送给主机B，其中会将ICMP报文的目的MAC改为主机B的MAC,源MAC改为网关的MAC，同时，在转发表中根据刚刚得到的三层转发信息添加主机A的表项，其中包括匹配的网段，MAC,出口VLAN ID,出口的PORT。

⑨ 主机B收到来自网关转发的ICMP报文后，向PCA发送应答ICMP，以同样的转发过程发送到主机A，此时由于转发表以及ARP表项中存在主机A的MAC，可以直接转发。


![image-20220212181443477.png](https://github.com/Create-python/wkf9721/blob/master/images/image-20220212181443477.png?raw=true)

![image-20220212181506987.png](https://github.com/Create-python/wkf9721/blob/master/images/image-20220212181506987.png?raw=true)

