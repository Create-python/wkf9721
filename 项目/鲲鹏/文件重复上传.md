```python
"""
usrls router
"""
from django.urls import path
from taskmanager import views, views_home, byte_alignment_check_views
from taskmanager.views_home import manage_whitelist
from taskmanager.views_home import whitelist_upload
from taskmanager.views_home import reset_status
from taskmanager.views_home import delete_whitelist_package
from taskmanager.views_home import upload, check_upload, delete_file
from taskmanager.views_home import build_migration_scan
from taskmanager.views_home import migration_scan_process
from taskmanager.views_home import content_check, migration_task_query
from report_process import report_view
from util.request_check import platform

urlpatterns = [
    path('histasknums/', report_view.query_his_report_threshold),
    path('modifyhistasknums/', report_view.modify_his_report_threshold),
    path('systeminfo/', views_home.system_list_info, name='systeminfo'),
    path('resetstatus/', reset_status, name='resetstatus'),
    path('whitelistmanage/', manage_whitelist, name='whitelistmanage'),
    path('upload/', upload, name='uploadinfo'),
    path('delete_file/', delete_file, name='delete_file'),
    path('check_upload/', check_upload, name='checkupload'),
    path('migrationscan/', build_migration_scan, name="migrationscan"),
    path('migrationscan/<str:task_id>/', migration_scan_process,
         name="migrationscanprocess"),
    path('migrationscaninfo/', content_check, name="migrationscaninfo"),
    path('migrationrunning/', migration_task_query, name="migrationrunning"),
    path('platform/', platform, name="platform"),
    path('delete/whitelist/package/', delete_whitelist_package,
         name='deletewhitelistpackage'),
    path('whitelist/package/', whitelist_upload, name='whitelistpackage'),
    path('', views.task_list, name='task_list'),
    path('taskundone/', views.task_undone, name='task_undone'),
    path('all/', views.del_all_task, name='del_all_task'),
    path('<str:task_id>/', views.del_task, name='del_task'),
    path('<str:task_id>/portinginfo/', views.info_task, name='portinginfo'),
    path('<str:task_id>/download/', views.download_task, name='download'),
    path('<str:task_id>/originfile/', views.modify_origin_file,
         name='originfile'),
    path('migration/bytealignment/task/',
         byte_alignment_check_views.byte_alignment_check_task),
    path('migration/bytealignment/taskresult/',
         byte_alignment_check_views.byte_alignment_check_task_result),
    path('migration/bytealignment/taskinfo/',
         byte_alignment_check_views.byte_alignment_check_task_info,),
    path('migration/bytealignment/task/<str:task_id>/',
         byte_alignment_check_views.byte_alignment_check_task_abort),
    path('migration/category/',
         byte_alignment_check_views.migration_preview_category)
]

views_home.py

"""
查询首页系统信息接口
"""
import os
import json
from datetime import datetime
import shutil
import pwd
import re

from django.db.models import Q
from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.response import Response

from resource import utils
from util.check_space import check_space
from util.request_check import check_before_upload_whitelist, \
    del_exist_upgrade_package, check_platform, FILE_CHECK_RETURN_INFO
from util.response import SuccessResponse, FailResponse, CommonResponse
from util import task_util, common_util
from util.verify_view import upload_verify
from usermanager.models import User
from taskmanager.models import Task
from taskmanager.whitelist_task import TaskQueue, TaskWhitelist
from taskmanager.migration_scan_task import MigrationScanTask, \
    MigrationTaskQueue
from upload_tool import file_upload
from upload_tool.upload_control import upload_control
from tool.porting.api.scan_api import ResetTaskStatus
from tool.kit_config import OsConfig, GccConfig, KitConfig, GfortranConfig
from .views import check_path, get_origin_and_suggestion_content
from tool.refactoring.refactoring import Refactor

LOGGER = utils.get_logger()

# 请求状态码
STATUS_SUCCESS = 0
STATUS_FAILED = 1
TASK_TYPE = ["whitelist", "solution", "solution_manage", "autopack"]
EVENT = {
    'whitelist_upload': 24,
    'upload_success': 50,
    'upload_failed': 51
}
SCAN_TYPE = {
    '0': 'sourcecode',
    '1': 'bytecheck',
    '2': 'precheck',
    '3': 'packagerebuild',
    '4': 'data',
}
RESPONSE_INFO = {
    "DELETE_FILE_SUCCESS": [STATUS_SUCCESS, "Delete file success", "删除文件成功"],
    "DELETE_FILE_FAIL": [STATUS_FAILED, "Delete file fail", "删除文件失败"],
    "EXCEPTION": [STATUS_FAILED, "Exception", "删除文件异常"],
    "FILE_NOT_EXIST": [STATUS_FAILED, "File not exist",
                       "删除的文件不存在"],
    "NO AUTHORITY": [STATUS_FAILED, "No authority", "权限不足"],
    "MISSING PARAMETER": [STATUS_FAILED, "Missing parameter", "缺少参数"],
    "CONTACT ADMINISTRATOR": [STATUS_FAILED, "Contact administrator to delete",
                              "请联系管理员删除"],
    "PATH DOESNT EXIST": [STATUS_FAILED, "Path doesnt exist", "路径不存在"],
    "NAME_INVALID": [STATUS_FAILED, "Name invalid", "无效名字"],
    "PARAMETER_INVALID": [STATUS_FAILED, "Parameter invalid", "参数不合法"],
}
RULE_PATH = ('sourcecode', 'bytecheck', 'precheck', 'packagerebuild',)

CHOICE = {
    'OVERRIDE': 'override',
    'NORMAL': 'normal',
    'SAVE_AS': 'save_as',
}


@api_view(['GET'])
@common_util.check_if_user_login()
def system_list_info(request):
    """
    查询首页系统信息接口
    :param request:
    :return: get
    """
    request.user.update_op_time()
    os_system_list = []
    for vaild_os_version in OsConfig.valid_os_version_transfer:
        os_system = dict()
        os_system['os_system'] = vaild_os_version
        vaild_os_version = vaild_os_version.lower().replace(' ', '')
        kernel = OsConfig.target_porting_os.get(
            vaild_os_version, '').get('kernel')
        os_system['kernel_default'] = kernel
        gcc = OsConfig.target_porting_os.get(
            vaild_os_version, '').get('gcc').upper()
        if gcc:
            gcc = list(gcc)
            gcc.insert(3, ' ')
            gcc = ''.join(gcc)
        os_system['gcc_default'] = gcc
        os_system_list.append(os_system)
    data = {
        'os_system_list': os_system_list,
        'gcc_list': GccConfig.valid_compiler_info_upper,
        'fortran_list': GfortranConfig.valid_compiler_info_upper,
        'construct_tools': KitConfig.valid_construct_tools
    }
    return SuccessResponse('success', '成功', data)


@api_view(['POST'])
@common_util.check_if_user_login()
def manage_whitelist(request):
    """
    创建白名单管理任务
    """
    request.user.update_op_time()
    response = check_space()
    response_body = {}
    if response:
        return Response(response, status.HTTP_200_OK)

    # 判断是否为有效的管理员用户和有效操作
    status_code, info, info_chinese, data = admin_user_check(request)
    if status_code == STATUS_FAILED:
        return FailResponse(info, info_chinese, data)
    try:
        task_info = int(request.data.get("option", ""))
    except ValueError as ex:
        LOGGER.info("Failed to convert the data type. Expect: %s" % str(ex))
        response_body["status"] = STATUS_FAILED
        response_body['info'] = "Invalid parameter"
        response_body['infochinese'] = u"非法参数"
        response_body['data'] = ""
        return Response(response_body, status=status.HTTP_400_BAD_REQUEST)

    LOGGER.debug('whitelist POST begin!')
    status_code, info, info_chinese, data = \
        create_whitelist_task(request, task_info)
    LOGGER.debug('whitelist POST end!')
    return CommonResponse(status_code, info, info_chinese, data)


def create_whitelist_task(request, task_info):
    """ 创建白名单任务，判断当前是否有任务在运行 """
    username = request.user.username
    status_code = STATUS_FAILED
    info = 'Operation failed.'
    info_chinese = u"操作失败。"
    data = {"task_name": ""}
    try:
        current = datetime.now().strftime('%Y%m%d%H%M%S')
        # 判断是否有: 1.同一时刻任务, 2.非白名单任务, 3.扫描和重打包任务
        task_judge = Task.objects.filter(
            (Q(user_name=username) & Q(task_type=2) &
             (Q(task_name=current) | Q(progress__lt=100))) |
            (Q(task_type__in=[0, 1]) & Q(status=1))
        ).exists()

        if not task_judge:
            taskrun = TaskWhitelist(username, task_info)
            if TaskQueue().add_task(taskrun):
                data = {"task_name": taskrun.task_name}
                utils.insert_operationlog(
                    username, 13 + task_info, 0, datetime.now(),
                    [24 + (task_info * 2), ''])
                status_code = STATUS_SUCCESS
                LOGGER.info('Success to add whitelist task. Option '
                            'code: %d', task_info)
                info = 'Successful operation.'
                info_chinese = u"操作成功。"
            else:
                # 添加任务失败，删除数据库无用任务
                Task.objects.filter(id=taskrun.task_id).delete()
                utils.insert_operationlog(
                    username, 13 + task_info, 1, datetime.now(),
                    [25 + (task_info * 2), ''])
                LOGGER.info('Failed to add whitelist task. Option '
                            'code: %d', task_info)
        else:
            utils.insert_operationlog(
                username, 13 + task_info, 1, datetime.now(),
                [25 + (task_info * 2), ''])
            LOGGER.info('Failed to add whitelist task. Option code: %d',
                        task_info)
            info = 'Failed to perform the whitelist operation ' \
                   'because a user is performing another task.'
            info_chinese = u"有用户正在执行其它任务，无法执行白名单相关操作。"
    except (IOError, OSError, ValueError, TypeError) as error:
        utils.insert_operationlog(
            username, 13 + task_info, 1, datetime.now(),
            [25 + (task_info * 2), ''])
        LOGGER.error('Failed to add whitelist task. '
                     'Option code: %d. Except:%s.', task_info, error)
    return status_code, info, info_chinese, data


@api_view(['POST'])
@common_util.check_if_user_login()
@common_util.check_is_admin_user()
def delete_whitelist_package(request):
    """
    功能:删除升级包
    参数:无
    返回值: 删除状态
    """
    return del_exist_upgrade_package(request)


@api_view(['POST', 'GET'])
@common_util.check_if_user_login()
@common_util.check_is_admin_user()
def whitelist_upload(request):
    """
    白名单上传
    """
    response = check_space()
    if response:
        return Response(response, status.HTTP_403_FORBIDDEN)
    # 判断是否为有效的管理员用户和有效操作
    username = str(request.user)
    if request.method == 'GET':
        return check_before_upload_whitelist(request)
    # 验证上传文件是否指定包
    filename = request.META.get("HTTP_FILENAME")
    if not filename.startswith('Whitelist-package') \
            or not filename.endswith('.tar.gz'):
        utils.insert_operationlog(
            username,
            EVENT['whitelist_upload'], STATUS_FAILED, datetime.now(),
            [EVENT['upload_failed'], '']
        )
        res_info = FILE_CHECK_RETURN_INFO.get('FILE_ERROR')
        return FailResponse(res_info.get('INFO'), res_info.get('CH_INFO'))
    # 上传文件，并根据上传情况返回失败还是成功
    if request.method == 'POST':
        filepath = os.path.normpath(
            os.path.join(KitConfig.tool_root_dir, username))
        upload_response = upload_verify(request, filepath)
        if upload_response.status_code != status.HTTP_200_OK:
            utils.insert_operationlog(
                username,
                EVENT['whitelist_upload'], STATUS_FAILED, datetime.now(),
                [EVENT['upload_failed'], '']
            )
        else:
            utils.insert_operationlog(
                username,
                EVENT['whitelist_upload'], STATUS_SUCCESS, datetime.now(),
                [EVENT['upload_success'], '']
            )
        return upload_response


@api_view(['POST'])
@common_util.check_if_user_login()
def reset_status(request):
    """
    清除任务状态
    """
    request.user.update_op_time()
    response = check_space()
    if response:
        return Response(response, status.HTTP_200_OK)

    try:
        task_type = request.data.get("tasktype", "")
        LOGGER.info("start reset %s task status!", task_type)
        if task_type not in TASK_TYPE:
            status_code = STATUS_FAILED
            info = "Wrong task type"
            info_chinese = "错误的任务类型"
        else:
            reset = ResetTaskStatus(task_type)
            result = reset.clear_status()
            if result:
                status_code = STATUS_SUCCESS
                info = "clear task status success"
                info_chinese = "任务状态清除成功"
            else:
                status_code = STATUS_FAILED
                info = "task status error"
                info_chinese = "任务状态异常"
    except Exception as err:
        LOGGER.error(err)
        status_code = STATUS_FAILED
        info = "unkown error"
        info_chinese = "未知错误"
    return CommonResponse(status_code, info, info_chinese)


def admin_user_check(request):
    """
    对输入参数进行统一的校验
    """
    user = User.objects.filter(username=request.user)
    status_code = STATUS_SUCCESS
    info = ""
    info_chinese = u""
    data = {}
    # 判断是否为管理员用户
    if user[0].id != 1:
        LOGGER.error('User permission error.')
        status_code = STATUS_FAILED
        info = "User permission error."
        info_chinese = u"用户权限错误。"
    else:
        # 二次密码校验
        whitelist_option = int(request.data.get("option", ""))
        if whitelist_option not in [0, 1, 2]:
            LOGGER.error('the whitelist option is wrong')
            status_code = STATUS_FAILED
            info = "Option parameter is wrong"
            info_chinese = u"输入的参数错误。"
        else:
            admin_password = request.data.get("password", "")
            admin_username = User.objects.get(id=1)
            if not admin_username.second_password_validate(admin_password):
                LOGGER.error('The administrator password is incorrect.')
                operation_number = [25, 27, 29]
                operation_event = [13, 14, 15]
                status_code = STATUS_FAILED
                info = "The password of the current user is incorrect or " \
                       "the user has been locked. "
                info_chinese = "当前用户密码错误或用户已锁定"
                # 写入日志
                utils.insert_operationlog(
                    username=admin_username,
                    event=operation_event[whitelist_option],
                    result=1,
                    times=datetime.now(),
                    detail=[operation_number[whitelist_option], ''])
            del admin_password
    return status_code, info, info_chinese, data


def check_name(file_name):
    check = re.compile(r'[\w\.\-\(\) ]{1,64}')
    if check.search(file_name).group() != file_name:
        return True
    return False


@api_view(['POST'])
@common_util.check_if_user_login()
def check_upload(request):
    """
    检查文件是否能够上传
    :param request:
    :return: 能否上传文件
    """
    response = check_space()
    if response:
        return Response(response, status.HTTP_200_OK)
    user_name = str(request.user)
    file_name = request.data.get("file_name")
    file_size = request.data.get("file_size")
    need_unzip = request.data.get("need_unzip")
    scan_type = request.data.get("scan_type")
    if not scan_type or scan_type not in SCAN_TYPE.keys():
        err_code = STATUS_FAILED
        info = "Input parameter error."
        ch_info = "输入参数错误。"
        data = {}
        return CommonResponse(err_code, info, ch_info, data)
    choice = request.data.get("choice")
    if choice == CHOICE['SAVE_AS']:
        invaild = check_name(file_name)
        if invaild:
            return response_content('NAME_INVALID')
    file_path = \
        os.path.join(KitConfig.tool_root_dir, user_name, SCAN_TYPE[scan_type])
    err_code, info, ch_info, data = file_upload.UploadFile(request). \
        file_upload_check(file_name, file_size, need_unzip, file_path, choice)

    LOGGER.info(info)
    if err_code:
        utils.insert_operationlog(user_name, 22, err_code, datetime.now(),
                                  [46, ""])
    return CommonResponse(err_code, info, ch_info, data)


@api_view(['POST'])
@common_util.check_if_user_login()
def upload(request):
    """
    上传文件接口
    :param request:
    :return: 上传结果
    """
    response = check_space()
    if response:
        return Response(response, status.HTTP_200_OK)
    user_name = request.user
    scan_type = request.META.get("HTTP_SCAN_TYPE")
    if not scan_type or scan_type not in SCAN_TYPE.keys():
        err_code = STATUS_FAILED
        info = "Input parameter error."
        ch_info = "输入参数错误。"
        data = {}
        return CommonResponse(err_code, info, ch_info, data)
    file_path = \
        os.path.join(KitConfig.tool_root_dir, str(user_name),
                     SCAN_TYPE[scan_type])
    file_field = "file"
    # 接收文件，验证，解压

    choice = request.META.get("HTTP_CHOICE", '')

    result = upload_control(file_field, file_path, request, choice)
    if len(result) == 3:
        result.append("")
    err_code, info, ch_info, data = result
    LOGGER.info(info)
    if err_code:
        utils.insert_operationlog(user_name, 22, err_code, datetime.now(),
                                  [46, ""])
    else:
        utils.insert_operationlog(user_name, 22, err_code, datetime.now(),
                                  [47, ""])
    return CommonResponse(err_code, info, ch_info, data)


@api_view(['DELETE'])
@common_util.check_if_user_login()
def delete_file(request):
    """
    删除文件接口
    :param request: 无
    :return: 删除文件的结果
    """
    response = check_space()
    if response:
        return Response(response, status.HTTP_200_OK)
    file_name = request.data.get('file_name', '')
    path = request.data.get('path', '')
    user = request.user
    workspace = user.workspace
    if not all((file_name, path)):
        return response_content("MISSING PARAMETER")
    if path == 'data':
        if user.role != User.ROLE_CHOIECES[0][0]:
            return response_content("CONTACT ADMINISTRATOR")
        file_path = os.path.join(Refactor.DATA_ROOT, file_name)
        workspace_path = Refactor.DATA_ROOT
    elif path in RULE_PATH:
        file_path = os.path.join(workspace, path, file_name)
        workspace_path = workspace + path + '/'
    else:
        return response_content("PATH DOESNT EXIST")
    file_path = os.path.realpath(file_path)

    if not file_path.startswith(workspace_path):
        return response_content("PARAMETER_INVALID")
    if not os.path.exists(file_path):
        return response_content("FILE_NOT_EXIST")
    info = os.stat(file_path)
    uid = info.st_uid
    f_info = pwd.getpwuid(uid)
    owner = f_info.pw_name
    if owner != 'porting':
        return response_content("NO AUTHORITY")
    try:
        if os.path.isfile(file_path):
            os.remove(file_path)
        else:
            shutil.rmtree(file_path)
        return response_content("DELETE_FILE_SUCCESS")
    except OSError as e:
        LOGGER.warning(str(e))
        return response_content("DELETE_FILE_FAIL")


def response_content(content):
    """
   返回结果信息
   :param : content
   :return: 结果信息
    """
    err_code = RESPONSE_INFO[content][0]
    info = RESPONSE_INFO[content][1]
    ch_info = RESPONSE_INFO[content][2]
    data = ''
    return CommonResponse(err_code, info, ch_info, data)


@api_view(['POST'])
@common_util.check_if_user_login()
def build_migration_scan(request):
    """
    x86平台32位-64位迁移
    :param request:
    :return: 迁移任务建立结果
    """
    response = check_space()
    if response:
        return Response(response, status.HTTP_200_OK)
    user_name = request.user.username
    scan_file = request.data.get("scan_file", "")  # 扫描文件名
    status_code, info, info_chinese = check_platform()
    if status_code == STATUS_FAILED:
        utils.insert_operationlog(user_name, 3, 1, datetime.now(), [5, ''])
        return FailResponse(info, info_chinese)
    if not scan_file:
        info = "scan_file is empty"
        info_chinese = "缺少scan_file参数"
        return FailResponse(info, info_chinese)
    user = User.objects.get(username=user_name)
    work_space = user.workspace
    file_path = os.path.join(
        KitConfig.tool_root_dir, str(user_name), 'precheck', scan_file)
    success, info, info_chinese = check_path(work_space, [file_path])
    if not success:
        return FailResponse(info, info_chinese)

    status_code, info, info_chinese, data = \
        create_migration_scan_task(user_name, file_path)
    return CommonResponse(status_code, info, info_chinese, data)


def create_migration_scan_task(user_name, file_path):
    """ 创建x86平台32位-64位迁移任务 """
    task_name = datetime.now().strftime('%Y%m%d%H%M%S')
    scan_param = {"task_type": 5, "source_path": file_path}
    task = init_migration_scan_task(task_name, user_name, file_path)
    status_code = STATUS_FAILED
    data = {}
    task_others = Task.objects.filter(user_name=user_name,
                                      task_type=5,
                                      status=1).exists()
    if task_others:
        status_code = STATUS_FAILED
        LOGGER.error('Failed to create task.')
        info = 'A porting pre-check task is being executed. ' \
               'Please try again later.'
        info_chinese = u"当前用户正在执行迁移预检任务，请稍后再试"
        utils.insert_operationlog(user_name, 3, 1, datetime.now(), [5, ''])
        return status_code, info, info_chinese, data
    task_others = Task.objects.filter(user_name=user_name,
                                      task_type=6,
                                      status=1).exists()
    if task_others:
        status_code = STATUS_FAILED
        LOGGER.error('Failed to create task.')
        info = 'A structure type definition alignment check task is ' \
               'being executed. Please try again later.'
        info_chinese = u"当前用户正在执行结构类型定义对齐检查任务，请稍后再试"
        utils.insert_operationlog(user_name, 3, 1, datetime.now(), [5, ''])
        return status_code, info, info_chinese, data
    try:
        taskrun = MigrationScanTask(user_name, scan_param, task_name)
        task.save()
        if MigrationTaskQueue().add_task(taskrun):
            status_code = STATUS_SUCCESS
            info = 'Task creation successful.'
            info_chinese = u"创建任务成功。"
            data = {'id': task_name}
        else:
            task.delete()
            LOGGER.error('Task creation failed.')
            info = 'Task creation failed.'
            info_chinese = u"创建任务失败。"
            utils.insert_operationlog(user_name, 3, 1, datetime.now(), [5, ''])
    except (IOError, OSError, ValueError, TypeError) as exp:
        LOGGER.error('Task creation failed: %s' % str(exp))
        status_code = STATUS_FAILED
        info = '%s' % str(exp)
        info_chinese = u"创建任务异常"
        utils.insert_operationlog(user_name, 3, 1, datetime.now(), [5, ''])
    return status_code, info, info_chinese, data


def init_migration_scan_task(task_name, user_name, file_path):
    """ 初始化x86平台32位-64位迁移任务 """
    task = Task(
        task_name=task_name,
        user_name=user_name,
        status=1,
        source_dir=file_path,
        task_type=5)
    return task


@api_view(['DELETE'])
@common_util.check_if_user_login()
def migration_scan_process(request, task_id):
    """
    32-64位迁移任务终止
    :param request:
    :param task_id:
    :return: del get
    """
    return task_util.stop(request, task_id, task_util.PORT_MIGRATION)


@api_view(['POST'])
@common_util.check_if_user_login()
def content_check(request):
    """
    获取迁移文件内容和迁移建议
    :param request:
    :return: task_id
    """
    file_path = request.data.get("file_path", "")
    task_name = request.data.get("task_name", "")
    try:
        content, suggestion_content = get_origin_and_suggestion_content(
            file_path, task_name)
    except IOError as error:
        info = "The path does not exist."
        info_chinese = u"路径不存在。"
        LOGGER.error(info + " Except:%s.", error)
        return FailResponse(info, info_chinese)

    task = Task.objects.get(
        task_name=task_name, user_name=request.user, task_type=5)
    if not task:
        info = "Failed to query the task list because the task or " \
               "user does not exist."
        info_chinese = u"查询任务列表失败，任务或用户不存在。"
        return FailResponse(info, info_chinese)
    scan_result_json = json.loads(task.scan_result)
    info = "Porting suggestion query succeeded."
    info_chinese = u"查询迁移建议成功。"
    data = {
        "content": content,
        "suggestioncontent": suggestion_content,
        "line": scan_result_json.get(file_path)
    }
    LOGGER.debug(info)
    return SuccessResponse(info, info_chinese, data)


@api_view(['GET'])
@common_util.check_if_user_login()
def migration_task_query(request):
    """
    查询当前用户是否有正在执行的32-64位迁移任务
    :param request:
    :return:
    """
    User.objects.filter(
        username=request.user).update(last_operating=datetime.now())
    LOGGER.debug('Query task undone')
    info = "Task execution complete."
    info_chinese = u"任务已全部执行完成。"
    data = {}
    LOGGER.debug('task_list check if there is running task')
    task_dict = Task.objects.filter(
        status=1, user_name=request.user, task_type=5)
    if task_dict:
        working_task = task_dict[0]
        if str(working_task.user_name) == str(request.user):
            info = "A task is running."
            info_chinese = u"有任务正在运行。"
            LOGGER.error('%s is running', working_task.task_name)
            data = {"id": working_task.task_name}
    return SuccessResponse(info, info_chinese, data)

file_upload.py

"""文件上传相关工具"""
import os
import shutil

from django.core.files.uploadhandler import TemporaryFileUploadHandler
from tool.kit_config import KitConfig
from tool.refactoring.refactoring import Refactor
from util import common_util

LOGGER = common_util.get_logger()

DATA_UPLOAD_MAX_MEMORY_SIZE = 1024 * 1024 * 500  # 接收文件大小上限500M
# 源码包支持的文件类型(需要解压)
ZIP_FILE_TYPE = [".zip", ".tar", ".tar.gz", ".gz", ".bz", ".bz2", ".tar.bz2"]
# 安装包支持的文件类型(不需要解压)
UNZIP_FILE_TYPE = [".rpm", ".deb", ".tar", ".jar", ".war", ".tar.gz"]

BUILD_FILE_TYPE = (".rpm", ".deb")
SUCCESS_CODE = 0
FAIL_CODE = 1

RESPONSE_INFO = {
    "FILE_PATH_NOT_EXIST": [FAIL_CODE, "Failed, file path not exist",
                            "指定路径不存在，上传失败"],
    "LACK_FILE_SIZE": [FAIL_CODE, "Lack file size", "缺少文件大小"],
    "FILE_EMPTY": [FAIL_CODE, "Failed, The file is empty", "文件为空"],
    "WRONG_FILE_TYPE": [FAIL_CODE, "Wrong file type", "文件类型错误"],
    "FILE_ALREADY_EXIST": [FAIL_CODE, "Failed, file already exist",
                           "文件已存在，上传失败"],
    "FILE_TOO_LARGE": [FAIL_CODE, "File too large", "文件超出最大限值"],
    "NAME_ERROR": [FAIL_CODE, "Name error", "文件名错误"],
    "UPLOAD_EXCEPTION": [FAIL_CODE, "Upload exception", "上传异常"],
    "FILE_RECEIVE_SUCCESS": [SUCCESS_CODE, "Upload success", "文件上传成功"],
    "MISS_PARA": [FAIL_CODE, "Missing parameter", "缺少参数"],
    "FILE_SIZE_TYPE_WRONG": [FAIL_CODE, "File_size type wrong",
                             "文件大小类型错误"],
    "FILE_SIZE_LARGE": [FAIL_CODE, "File_size too large", "文件过大"],
    "CHECK_SUCCESS": [SUCCESS_CODE, "Check success", "校验成功"],
    "DELETE_FILE_FAIL": [FAIL_CODE, "Delete file fail", "删除文件失败"],
}
CHOICE = {
    'OVERRIDE': 'override',
    'NORMAL': 'normal',
    'SAVE_AS': 'save_as',
}


class UploadFile:
    """实现文件上传功能"""

    def __init__(self, request, file_field=None):
        self.request = request
        self.file_path = None
        self.file_field = file_field  # 前端传递文件的字段
        self.file_process = 0

    def get_file_name(self):
        """获取文件名"""
        return self.request.FILES.get(self.file_field).name

    def get_file_size(self):
        """获取文件大小"""
        return self.request.FILES.get(self.file_field).size

    def get_file_process(self):
        """计算文件进度"""

    @staticmethod
    def file_upload_check(file_name, file_size, need_unzip, file_path,
                          choice=None):
        """文件上传前校验"""
        if not all([file_name, str(file_size), need_unzip]):
            response = RESPONSE_INFO["MISS_PARA"].copy()
            response.append({})
            return response
        if not isinstance(file_size, int):
            response = RESPONSE_INFO["FILE_SIZE_TYPE_WRONG"].copy()
            response.append({})
            return response
        if file_size > DATA_UPLOAD_MAX_MEMORY_SIZE:
            response = RESPONSE_INFO["FILE_SIZE_LARGE"].copy()
            response.append({})
            return response

        return UploadFile.file_upload_check_sub(need_unzip, file_name,
                                                file_path, choice)

    @staticmethod
    def build_file_upload_check(file_name, file_size, file_path, choice):
        """
        判断文件大小和类型
        :param file_name: 文件名
        :param file_size: 文件大小
        :param file_path: 文件的路径
        :param choice: 选择的功能 覆盖 正常上传  另存为
        :return  返回文件过大或者类型错误的信息
        """
        if not isinstance(file_size, int):
            return RESPONSE_INFO.get("FILE_SIZE_TYPE_WRONG")
        if file_size > DATA_UPLOAD_MAX_MEMORY_SIZE:
            return RESPONSE_INFO.get("FILE_SIZE_LARGE")

        return UploadFile.build_file_upload_check_sub(file_name, file_path,
                                                      choice)

    @staticmethod
    def build_file_upload_check_sub(file_name, file_path, choice):

        """
        判断构建软件包文件是否合法
        :param file_suffix: 文件名后缀
        :param if_pack_exist: 完整文件是否存在
        :param if_unzip_file_exist: 文件的名字是否存在
        :param file_name: 文件名
        :param file_path: 文件的路径
        :param choice: 选择的功能 覆盖 正常上传  另存为
        :return  检查出的信息
        """
        file_prefix, file_suffix = get_prefix_suffix(file_name)
        file_save_path = os.path.join(file_path, file_name)
        if_pack_exist = os.path.exists(file_save_path)
        # 判断源码包的后缀是否在规定的类型里
        if file_path != Refactor.DATA_ROOT and file_suffix not in BUILD_FILE_TYPE:
            response = RESPONSE_INFO["WRONG_FILE_TYPE"].copy()
            response.append({})
            return response
        if choice == CHOICE['OVERRIDE']:
            response = UploadFile.if_exist_file(file_path, file_name)
            if response:
                return response
        if choice != CHOICE['OVERRIDE'] and if_pack_exist:
            response = RESPONSE_INFO["FILE_ALREADY_EXIST"].copy()
            dic, file_name = UploadFile.produce_name(file_name, file_path)
            response.append(dic)
            return response
        response = RESPONSE_INFO["CHECK_SUCCESS"].copy()
        response.append(file_name)
        return response

    @staticmethod
    def file_upload_check_sub(need_unzip, file_name, file_path, choice=None):

        """
        判断源码扫描，64位迁移，字节对齐文件是否合法
        :param file_suffix: 文件名后缀
        :param if_pack_exist: 完整文件是否存在
        :param if_unzip_file_exist: 文件的名字是否存在
        :param file_name: 文件名
        :param file_path: 文件的路径
        :param choice: 选择的功能
        :return  检查出的信息
        """
        file_prefix, file_suffix = get_prefix_suffix(file_name)
        file_save_path = os.path.join(file_path, file_name)
        file_unzip_path = os.path.join(file_path, file_prefix)
        if_pack_exist = os.path.exists(file_save_path)
        if_unzip_file_exist = os.path.exists(file_unzip_path)
        need_unzip = need_unzip
        # 判断源码包的后缀是否在规定的类型里
        if (need_unzip == 'false' and file_suffix not in UNZIP_FILE_TYPE) or (
                need_unzip == 'true' and file_suffix not in ZIP_FILE_TYPE):
            response = RESPONSE_INFO["WRONG_FILE_TYPE"].copy()
            response.append({})
            return response
        if choice == CHOICE['OVERRIDE']:
            response = UploadFile.if_exist_file(file_path, file_name)
            if response:
                return response
        if choice != CHOICE['OVERRIDE'] and (
                need_unzip and (if_pack_exist or if_unzip_file_exist) or
                not need_unzip and if_pack_exist):
            response = RESPONSE_INFO["FILE_ALREADY_EXIST"].copy()
            dic, file_name = UploadFile.produce_name(file_name, file_path,
                                                     need_unzip)
            response.append(dic)
            return response

        response = RESPONSE_INFO["CHECK_SUCCESS"].copy()
        response.append(file_name)
        return response

    @staticmethod
    def produce_name(file_name, file_path, need_unzip=None):
        file_name, new_file_name, suffix = UploadFile.rename_file(
            file_name, file_path, need_unzip)
        dic = {}
        dic['old_name'] = file_name
        dic['new_name'] = new_file_name
        dic['suffix'] = suffix
        return dic, file_name

    @staticmethod
    def rename_file(file_name, file_path, need_unzip):
        """重新返回个新名字
        :param file_path:  文件要保存的路径
        :param file_name: 文件名字
        :return: 旧名字 新名字 后缀名
        """
        unzip_pack = (
            ".zip", ".tar", ".tar.gz", ".gz", ".bz", ".bz2", ".tar.bz2")
        prefix, suffix = get_prefix_suffix(file_name)
        is_special_file = \
            file_path == Refactor.DATA_ROOT or suffix not in unzip_pack \
            or need_unzip == 'false'
        file_temp_name = file_name if is_special_file else prefix
        new_file_name = file_temp_name
        num = 0
        while new_file_name in os.listdir(file_path):
            num += 1
            num_list1 = [prefix, "_", str(num), suffix]
            num_list2 = [prefix, "_", str(num)]
            new_file_name = "".join(num_list1) if is_special_file else "".join(
                num_list2)
        if is_special_file:
            new_file_name, _ = get_prefix_suffix(new_file_name)
        return prefix, new_file_name, suffix

    def upload_file(self, file_path, type_limit=None):
        """
        接收上传的文件
        :param file_path:  文件要保存的路径
        :param type_limit: 是否限制上传文件类型
               不传表示默认限制类型，[]表示不限制类型，[".zip"]表示限制为zip类型
        :return: [FAIL_CODE, "Lack file size", "缺少文件大小"]
        """
        tmp_path = os.path.join(KitConfig.tool_root_dir, "tmp")
        if not os.path.exists(tmp_path):
            os.mkdir(tmp_path)
        if not os.path.exists(file_path):
            return RESPONSE_INFO.get("FILE_PATH_NOT_EXIST")
        self.request.session["file_path"] = file_path
        self.request.session["type_limit"] = type_limit
        file_size = self.request.META.get("CONTENT_LENGTH")
        if not file_size:
            return RESPONSE_INFO.get("LACK_FILE_SIZE")
        elif int(file_size) > DATA_UPLOAD_MAX_MEMORY_SIZE:
            return RESPONSE_INFO.get("FILE_TOO_LARGE")
        self.file_path = file_path
        try:
            file = self.request.FILES.get(self.file_field)
            if not file:
                return RESPONSE_INFO.get("FILE_EMPTY")
            file_name = self.get_file_name()
            file_save_path = os.path.join(self.file_path, file_name)
            with open(file_save_path, 'wb') as f:
                for chunk in file.chunks():
                    f.write(chunk)
            self.request.session.pop("file_path")
            self.request.session.pop("type_limit")
            response_content = RESPONSE_INFO.get("FILE_RECEIVE_SUCCESS")
        except NameError as name_error:
            LOGGER.warning("Name error. Except:%s.", name_error)
            response_content = RESPONSE_INFO.get("NAME_ERROR")
        except TypeError as type_error:
            LOGGER.warning("Wrong file type. Except:%s.", type_error)
            response_content = RESPONSE_INFO.get("WRONG_FILE_TYPE")
        except FileExistsError as error:
            LOGGER.warning("Failed, file already exist. Except:%s.", error)
            response_content = RESPONSE_INFO.get("FILE_ALREADY_EXIST")
        except ConnectionResetError as reset_error:
            LOGGER.warning("File too large. Except:%s.", reset_error)
            response_content = RESPONSE_INFO.get("FILE_TOO_LARGE")
        except Exception as exp:
            LOGGER.warning("Upload exception. Except:%s.", exp)
            RESPONSE_INFO["UPLOAD_EXCEPTION"][1] = str(exp)
            response_content = RESPONSE_INFO.get("UPLOAD_EXCEPTION")
        return response_content

    @staticmethod
    def if_exist_file(file_path, file_name):
        """如果文件有同名文件会删除后继续上传新文件
        :param file_path:  文件要保存的路径
        :param file_name:  文件的名字
        :return: 如果删除失败返回前端信息
        """
        name, suffix = get_prefix_suffix(file_name)
        suffix_list = ('.rpm', '.deb', 'war', 'jar')
        if suffix in suffix_list:
            name = '%s%s' % (name, suffix)
        if file_path != Refactor.DATA_ROOT:
            file_name_path = os.path.join(file_path, name)
            file_pack_path = os.path.join(file_path, file_name)
        else:

            file_name_path = os.path.join(file_path, file_name)
            file_pack_path = ''
        try:
            if os.path.exists(file_name_path):
                UploadFile.delete_path_file(file_name_path)
            if os.path.exists(file_pack_path):
                UploadFile.delete_path_file(file_pack_path)
        except OSError as e:
            response = RESPONSE_INFO["DELETE_FILE_FAIL"].copy()
            response.append({str(e)})
            return response

    @staticmethod
    def delete_path_file(file_path):
        """删除里面文件
        :param file_path:  文件要保存的路径
        """
        if os.path.isfile(file_path):
            os.remove(file_path)
        else:
            shutil.rmtree(file_path)


class CheckFileUploadHandler(TemporaryFileUploadHandler):
    """接受文件，并对文件大小，路径进行验证"""

    def __init__(self, request=None):
        super().__init__(request)
        self.total_upload = 0
        self.request = request

    def new_file(self, field_name, file_name, content_type, content_length,
                 charset=None, content_type_extra=None):
        if not file_name:
            raise NameError
        file_prefix, file_suffix = get_prefix_suffix(file_name)
        need_unzip = self.request.META.get("HTTP_NEED_UNZIP") == "true"
        type_limit = self.request.session["type_limit"]
        self.check_type(file_suffix, need_unzip, type_limit)
        file_save_path = os.path.join(self.request.session["file_path"],
                                      file_name)
        file_unzip_path = os.path.join(self.request.session["file_path"],
                                       file_prefix)
        if_pack_exist = os.path.exists(file_save_path)
        if_unzip_file_exist = os.path.exists(file_unzip_path)
        if (need_unzip and (if_pack_exist or if_unzip_file_exist)) \
                or (not need_unzip and if_pack_exist):
            raise FileExistsError
        super().new_file(field_name, file_name, content_type,
                         content_length,
                         charset=None, content_type_extra=None)

    @staticmethod
    def check_type(file_suffix, need_unzip, type_limit):
        """
        :param file_suffix: 文件后缀名
        :param need_unzip: 是否需要解压
        :param type_limit: 是否限制上传文件类型
               不传表示默认限制类型，[]表示不限制类型，[".zip"]表示限制为zip类型
        """
        if type_limit is None:
            # 判断源码包的后缀是否在规定的类型里
            if (not need_unzip and file_suffix not in UNZIP_FILE_TYPE) \
                    or (need_unzip and file_suffix not in ZIP_FILE_TYPE):
                raise TypeError
        elif isinstance(type_limit, list) and len(type_limit) > 0 \
                and file_suffix not in type_limit:
            raise TypeError

    def receive_data_chunk(self, raw_data, start):
        self.total_upload += len(raw_data)
        if self.total_upload > int(self.request.META.get("CONTENT_LENGTH")):
            raise ConnectionResetError
        self.file.write(raw_data)


def get_prefix_suffix(file_name):
    """获取文件的前缀和后缀"""
    if file_name.endswith(".tar.gz"):
        file_prefix = file_name[:-7]
        file_suffix = ".tar.gz"
    elif file_name.endswith(".tar.bz2"):
        file_prefix = file_name[:-8]
        file_suffix = ".tar.bz2"
    else:
        file_prefix, file_suffix = os.path.splitext(file_name)
    return file_prefix, file_suffix

upload_control.py

"""控制整个文件上传和解压流程"""
import os
import shutil

from upload_tool.file_upload import UploadFile
from upload_tool.unzip_file import UnzipTool

SUCCESS_CODE = 0
FAIL_CODE = 1

RESPONSE_INFO = {
    "FILE_NAME_ERROR": [FAIL_CODE, "File name error", "文件名错误"],
    "NOR_SUPPORT_TYPE": [FAIL_CODE, "Not support type", "不支持的格式"],
    "EXCEPTION": [FAIL_CODE, "Exception", "权限更改异常"],
    "SUCCESS": [SUCCESS_CODE, "Upload and decompress successfully",
                "上传并解压成功"],
    "DELETE_FILE_FAIL": [FAIL_CODE, "delete file fail",
                         "删除文件失败"],
    "OVERRIDE_FLIE_DOESNT_EXIST": [FAIL_CODE, "override file doesn't exist",
                                   "覆盖的文件不存在"],
}


def upload_control(file_field, file_path, request, choice=None):
    """控制上传文件, 以及解压整个流程
    :param file_path:  文件要保存的路径
    :param file_field: 前端传来字样
    :param choice: 选择上传的方式
    :return: 返回是否上传成功的信息
    """

    file_name, upload_result = upload_file_process(file_field, file_path,
                                                   request)
    if upload_result[0] == 1:
        return upload_result
    response = upload_way(file_path, request, file_name, upload_result,
                          choice)
    return response


def upload_file_process(file_field, file_path, request,
                        type_limit=None):
    upload_file_obj = UploadFile(request, file_field)
    upload_result = upload_file_obj.upload_file(file_path, type_limit)
    if upload_result[0] == 1:
        return '', upload_result
    file_name = upload_file_obj.get_file_name()
    if not file_name:
        file_name = None
    return file_name, upload_result


def upload_way(file_path, request, file_name, upload_result, choice):
    """上传后进行文件解压之前的判断
    :param file_path:  文件要保存的路径
    :param file_name: 前端传来字样
    :param upload_result: 选择上传的方式
    :return: [FAIL_CODE, "Lack file size", "缺少文件大小"]
    """
    need_unzip = request.META.get("HTTP_NEED_UNZIP") == "true"
    if not need_unzip:
        os.chmod(os.path.join(file_path, file_name), 0o644)
        result = upload_result.copy()
        result.append(file_name)
        return result
    # 解压文件
    zip_file_obj = UnzipTool(file_path, file_name)
    file_suffix = zip_file_obj.file_suffix
    if file_suffix == ".zip":
        zip_result = zip_file_obj.unzip(file_name, choice)
    else:
        zip_result = zip_file_obj.untar(file_name, choice)

    file_all_path = zip_file_obj.file_path_func()
    dir_all_path = zip_file_obj.unzip_path_func()
    if zip_result[0] == 1:
        if os.path.exists(file_all_path):
            os.remove(file_all_path)
        return zip_result
    # 如果这里有参数，表示不更改权限，直接返回
    if request.META.get("HTTP_NOT_CHMOD") == "true":
        os.remove(file_all_path)
        response = RESPONSE_INFO["SUCCESS"].copy()
        response.append(zip_result[3])
        return response
    # 更改权限和删除压缩包
    return change_mod(dir_all_path, file_all_path, zip_result[3])


def change_mod(dir_all_path, file_all_path, file_name):
    """更改解压后文件权限并清理环境"""
    try:
        for (root, dirs, files) in os.walk(dir_all_path):
            os.chmod(root, 0o700)
            for f in files:
                chmod_sub(f, root, dir_all_path)
        os.remove(file_all_path)
    except Exception as exp:
        if os.path.exists(file_all_path):
            os.remove(file_all_path)
        if os.path.exists(dir_all_path):
            shutil.rmtree(dir_all_path)
        RESPONSE_INFO["EXCEPTION"][1] = str(exp)
        return RESPONSE_INFO["EXCEPTION"]
    response = RESPONSE_INFO["SUCCESS"].copy()
    response.append(file_name)
    return response


def chmod_sub(f, root, dir_all_path):
    path = os.path.join(root, f)
    if os.path.exists(path) and dir_all_path in path \
            and not os.path.islink(path):
        os.chmod(path, 0o600)

unzip_file.py

"""解压文件方法"""

import os
import zipfile
import tarfile
import shutil
import subprocess
import re

from upload_tool.file_upload import get_prefix_suffix

MAX_SIZE = 1024 * 1024 * 1024

SUCCESS_CODE = 0
FAIL_CODE = 1

RESPONSE_INFO = {
    "NOT_VALID_FILE": [FAIL_CODE, "Not a valid compressed file",
                       "不是有效的压缩文件"],
    "FILE_ALREADY_EXIST": [FAIL_CODE,
                           "Decompression failed. The folder in the compressed package already exists on the server.",
                           "解压失败，压缩文件中的目录在服务器已存在"],
    "FILE_TOO_LARGE": [FAIL_CODE, "Unzip file too large", "解压后文件超过限值"],
    "UNZIP_SUCCESS": [SUCCESS_CODE, "Unzip success", "解压成功"],
    "UNZIP_EXCEPTION": [FAIL_CODE, "Unzip exception", "解压异常"],
    "CANT_FIND_FILE": [FAIL_CODE, "No folder is found in the package",
                       "压缩包内未找到文件夹"],
    "TOO_MANY_FILES": [FAIL_CODE,
                       "The number of folders after decompression is greater than 1",
                       "解压后的文件夹数量大于1"],
}
CHOICE = {
    'OVERRIDE': 'override',
    'NORMAL': 'normal',
    'SAVE_AS': 'save_as',
}


class UnzipTool:
    """解压文件类"""

    def __init__(self, path, file_name):
        self.path = path  # 文件路径
        self.file_name = file_name  # 文件名
        self.file_prefix, self.file_suffix = self.get_file_prefix_suffix()
        self.file_path = os.path.join(self.path, self.file_name)
        self.unzip_path = None

    def unzip_path_func(self):
        """获取包解压后的路径"""
        return self.unzip_path

    def file_path_func(self):
        """获取包的路径"""
        return self.file_path

    def get_file_prefix_suffix(self):
        """获取包名的的前缀和后缀"""
        file_prefix, file_suffix = get_prefix_suffix(self.file_name)
        return file_prefix, file_suffix

    def clean_unzip_file(self):
        """解压失败时，清理解压出的文件夹"""
        if self.unzip_path and os.path.exists(self.unzip_path):
            shutil.rmtree(self.unzip_path)

    @staticmethod
    def calc_space(path):
        """计算解压空间"""
        size = subprocess.Popen(['du', '-s', path],
                                stdout=subprocess.PIPE).communicate()
        return float(re.findall(r'[.\d]+', str(size))[0])

    def unzip(self, file_name=None, choice=None):
        """
        解压zip, rar, war, jar包
        :return: [SUCCESS_CODE, "Unzip success", "解压成功"]
        """
        try:
            is_zip_file = zipfile.is_zipfile(self.file_path)
            current_size = 0
            srcfile = zipfile.ZipFile(self.file_path, "r")
            temp_path = self.make_temp_file()
            if not is_zip_file:
                shutil.rmtree(temp_path)
                return RESPONSE_INFO.get("NOT_VALID_FILE")
            for info in srcfile.infolist():
                current_size += info.file_size
                if current_size >= MAX_SIZE:
                    self.clean_unzip_file()
                    response = RESPONSE_INFO["FILE_TOO_LARGE"].copy()
                    response.append({})
                    shutil.rmtree(temp_path)
                    return response
                srcfile.extract(info.filename, temp_path)
            return self.check_untar(temp_path, file_name, choice)
        except Exception as exp:
            self.clean_unzip_file()
            RESPONSE_INFO["UNZIP_EXCEPTION"][1] = str(exp)
            response = RESPONSE_INFO["UNZIP_EXCEPTION"].copy()
            response.append({})
            return response

    def make_temp_file(self):
        """
        :return: 临时解压的路径
        """
        os.chdir(self.path)
        temp_path = os.path.join(self.path, "temp_tar")
        if os.path.exists(temp_path):
            shutil.rmtree(temp_path)
        os.mkdir(temp_path)
        return temp_path

    def untar(self, file_name=None, choice=None):
        """
        解压tar, tar.gz, gz, tar.bz2, bz2, bz包
        :return: [SUCCESS_CODE, "Unzip success", "解压成功"]
        """
        try:
            temp_path = self.make_temp_file()
            is_whitelist_migration = False
            is_tar_file = tarfile.is_tarfile(self.file_path)
            if not is_tar_file:
                if self.file_path.endswith(".tar.bz2"):
                    return self.untar_bz2(self.file_path, temp_path, file_name,
                                          choice)
                else:
                    response = RESPONSE_INFO["NOT_VALID_FILE"].copy()
                    response.append({})
                    shutil.rmtree(temp_path)
                    return response
            current_size = 0
            srcfile = tarfile.open(self.file_path)
            first_dir_path = list(srcfile.getmembers())[0].name
            self.unzip_path = os.path.join(self.path, first_dir_path)
            if (choice and choice != CHOICE['SAVE_AS']) and os.path.exists(
                    self.unzip_path):
                shutil.rmtree(temp_path)
                response = RESPONSE_INFO["FILE_ALREADY_EXIST"].copy()
                response.append({})
                return response
            is_whitelist_migration = self.check_whilelist_migration()
            if is_whitelist_migration:
                temp_path = self.path
            for info in srcfile.getmembers():
                current_size += info.size
                if current_size >= MAX_SIZE:
                    self.clean_unzip_file()
                    response = RESPONSE_INFO["FILE_TOO_LARGE"].copy()
                    response.append({})
                    return response
                srcfile.extract(info.name, temp_path)
            if is_whitelist_migration:
                response = RESPONSE_INFO["UNZIP_SUCCESS"].copy()
                response.append(file_name)
                return response
            return self.check_untar(temp_path, file_name, choice)
        except Exception as exp:
            self.clean_unzip_file()
            RESPONSE_INFO["UNZIP_EXCEPTION"][1] = str(exp)
            response = RESPONSE_INFO["UNZIP_EXCEPTION"].copy()
            response.append({})
            return response

    def check_whilelist_migration(self):
        if (self.file_name.startswith('Whitelist') and self.file_name.
                endswith('.tar.gz')) or \
                (self.file_name.startswith('Migration-package')
                 and self.file_name.endswith('.tar.gz')):
            return True
        else:
            return False

    def untar_bz2(self, file_path, temp_path, file_name=None, choice=None):
        os.chdir(self.path)
        sp = subprocess.Popen(["tar", "-jxf", file_path, "-C", temp_path],
                              shell=False)
        while True:
            used = self.calc_space(temp_path)
            if used > MAX_SIZE:
                sp.terminate()
                if os.path.exists(temp_path):
                    shutil.rmtree(temp_path)
                response = RESPONSE_INFO["FILE_TOO_LARGE"].copy()
                response.append({})
                return response
            if sp.poll() is not None:
                return self.check_untar(temp_path, file_name, choice)

    def check_untar(self, temp_path, file_name=None, choice=None):

        file_list = os.listdir(temp_path)
        if len(file_list) != 1:
            if os.path.exists(temp_path):
                shutil.rmtree(temp_path)
            response = RESPONSE_INFO["TOO_MANY_FILES"].copy()
            response.append({})
            return response
        self.unzip_path = os.path.join(self.path, file_list[0])
        if os.path.isfile(os.path.join(temp_path, file_list[0])):
            shutil.rmtree(temp_path)
            response = RESPONSE_INFO["CANT_FIND_FILE"].copy()
            response.append({})
            return response
        if choice and choice != CHOICE['SAVE_AS'] and os.path.exists(
                self.unzip_path):
            shutil.rmtree(temp_path)
            response = RESPONSE_INFO["FILE_ALREADY_EXIST"].copy()
            response.append({})
            return response

        if file_name:
            file_name, file_suffix = get_prefix_suffix(file_name)
            old_name_path = os.path.join(temp_path, file_list[0])
            new_name_path = os.path.join(temp_path, file_name)
            os.rename(old_name_path, new_name_path)
        else:
            file_name = file_list[0]
        new_path = os.path.join(self.path, file_name)
        shutil.copytree(os.path.join(temp_path, file_name), new_path,
                        symlinks=True, ignore_dangling_symlinks=True)
        shutil.rmtree(temp_path)
        response = RESPONSE_INFO.get("UNZIP_SUCCESS").copy()
        response.append(file_name)
        return response
```

